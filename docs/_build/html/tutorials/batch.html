<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Understand Batch &mdash; Tianshou 0.5.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/style.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/documentation_options.js?v=b9afe91b"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="https://cdn.jsdelivr.net/npm/vega@5.20.2"></script>
        <script src="https://cdn.jsdelivr.net/npm/vega-lite@5.1.0"></script>
        <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.17.0"></script>
        <script src="../_static/js/copybutton.js?v=7db002fe"></script>
        <script src="../_static/js/benchmark.js?v=1091b9f3"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Multi-Agent RL" href="tictactoe.html" />
    <link rel="prev" title="Basic concepts in Tianshou" href="concepts.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Tianshou
              <img src="../_static/tianshou-logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.5.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="get_started.html">Get Started with Jupyter Notebook</a></li>
<li class="toctree-l1"><a class="reference internal" href="dqn.html">Deep Q Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="concepts.html">Basic concepts in Tianshou</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Understand Batch</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#hierarchical-named-tensors">Hierarchical Named Tensors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-usages">Basic Usages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-does-batch-contain">What Does Batch Contain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#construction-of-batch">Construction of Batch</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-manipulation-with-batch">Data Manipulation With Batch</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-topics">Advanced Topics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#key-reservations">Key Reservations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#length-and-shape">Length and Shape</a></li>
<li class="toctree-l3"><a class="reference internal" href="#aggregation-of-heterogeneous-batches">Aggregation of Heterogeneous Batches</a></li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous-notes">Miscellaneous Notes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tictactoe.html">Multi-Agent RL</a></li>
<li class="toctree-l1"><a class="reference internal" href="logger.html">Logging Experiments</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmark.html">Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">Cheat Sheet</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/tianshou.data.html">tianshou.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/tianshou.env.html">tianshou.env</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/tianshou.policy.html">tianshou.policy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/tianshou.trainer.html">tianshou.trainer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/tianshou.exploration.html">tianshou.exploration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/tianshou.utils.html">tianshou.utils</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Community</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to Tianshou</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributor.html">Contributor</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Tianshou</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Understand Batch</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/tutorials/batch.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="understand-batch">
<span id="batch-concept"></span><h1>Understand Batch<a class="headerlink" href="#understand-batch" title="Link to this heading">¶</a></h1>
<p><a class="reference internal" href="../api/tianshou.data.html#tianshou.data.Batch" title="tianshou.data.Batch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Batch</span></code></a> is the internal data structure extensively used in Tianshou. It is designed to store and manipulate hierarchical named tensors. This tutorial aims to help users correctly understand the concept and the behavior of <a class="reference internal" href="../api/tianshou.data.html#tianshou.data.Batch" title="tianshou.data.Batch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Batch</span></code></a> so that users can make the best of Tianshou.</p>
<p>The tutorial has three parts. We first explain the concept of hierarchical named tensors, and introduce basic usage of <a class="reference internal" href="../api/tianshou.data.html#tianshou.data.Batch" title="tianshou.data.Batch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Batch</span></code></a>, followed by advanced topics of <a class="reference internal" href="../api/tianshou.data.html#tianshou.data.Batch" title="tianshou.data.Batch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Batch</span></code></a>.</p>
<section id="hierarchical-named-tensors">
<h2>Hierarchical Named Tensors<a class="headerlink" href="#hierarchical-named-tensors" title="Link to this heading">¶</a></h2>
<aside class="sidebar">
<p class="sidebar-title">The structure of a Batch shown by a tree</p>
<figure class="align-default">
<img alt="../_images/batch_tree.png" src="../_images/batch_tree.png" />
</figure>
</aside>
<p>“Hierarchical named tensors” refers to a set of tensors where their names form a hierarchy. Suppose there are four tensors <code class="docutils literal notranslate"><span class="pre">[t1,</span> <span class="pre">t2,</span> <span class="pre">t3,</span> <span class="pre">t4]</span></code> with names <code class="docutils literal notranslate"><span class="pre">[name1,</span> <span class="pre">name2,</span> <span class="pre">name3,</span> <span class="pre">name4]</span></code>, where <code class="docutils literal notranslate"><span class="pre">name1</span></code> and <code class="docutils literal notranslate"><span class="pre">name2</span></code> belong to the same namespace <code class="docutils literal notranslate"><span class="pre">name0</span></code>, then the full name of tensor <code class="docutils literal notranslate"><span class="pre">t1</span></code> is <code class="docutils literal notranslate"><span class="pre">name0.name1</span></code>. That is, the hierarchy lies in the names of tensors.</p>
<p>We can describe the structure of hierarchical named tensors using a tree in the right. There is always a “virtual root” node to represent the whole object; internal nodes are keys (names), and leaf nodes are values (scalars or tensors).</p>
<p>Hierarchical named tensors are needed because we have to deal with the heterogeneity of reinforcement learning problems. The abstraction of RL is very simple, just:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">state</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">reward</span></code> and <code class="docutils literal notranslate"><span class="pre">done</span></code> are simple, they are mostly scalar values. However, the <code class="docutils literal notranslate"><span class="pre">state</span></code> and <code class="docutils literal notranslate"><span class="pre">action</span></code> vary with environments. For example, <code class="docutils literal notranslate"><span class="pre">state</span></code> can be simply a vector, a tensor, or a camera input combined with sensory input. In the last case, it is natural to store them as hierarchical named tensors. This hierarchy can go beyond <code class="docutils literal notranslate"><span class="pre">state</span></code> and <code class="docutils literal notranslate"><span class="pre">action</span></code>: we can store <code class="docutils literal notranslate"><span class="pre">state</span></code>, <code class="docutils literal notranslate"><span class="pre">action</span></code>, <code class="docutils literal notranslate"><span class="pre">reward</span></code>, and <code class="docutils literal notranslate"><span class="pre">done</span></code> together as hierarchical named tensors.</p>
<p>Note that, storing hierarchical named tensors is as easy as creating nested dictionary objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;done&#39;</span><span class="p">:</span> <span class="n">done</span><span class="p">,</span>
    <span class="s1">&#39;reward&#39;</span><span class="p">:</span> <span class="n">reward</span><span class="p">,</span>
    <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;camera&#39;</span><span class="p">:</span> <span class="n">camera</span><span class="p">,</span>
        <span class="s1">&#39;sensory&#39;</span><span class="p">:</span> <span class="n">sensory</span>
    <span class="p">}</span>
    <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;direct&#39;</span><span class="p">:</span> <span class="n">direct</span><span class="p">,</span>
        <span class="s1">&#39;point_3d&#39;</span><span class="p">:</span> <span class="n">point_3d</span><span class="p">,</span>
        <span class="s1">&#39;force&#39;</span><span class="p">:</span> <span class="n">force</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The real problem is how to <strong>manipulate them</strong>, such as adding new transition tuples into replay buffer and dealing with their heterogeneity. <code class="docutils literal notranslate"><span class="pre">Batch</span></code> is designed to easily create, store, and manipulate these hierarchical named tensors.</p>
</section>
<section id="basic-usages">
<h2>Basic Usages<a class="headerlink" href="#basic-usages" title="Link to this heading">¶</a></h2>
<p>Here we cover some basic usages of <code class="docutils literal notranslate"><span class="pre">Batch</span></code>, describing what <code class="docutils literal notranslate"><span class="pre">Batch</span></code> contains, how to construct <code class="docutils literal notranslate"><span class="pre">Batch</span></code> objects and how to manipulate them.</p>
<section id="what-does-batch-contain">
<h3>What Does Batch Contain<a class="headerlink" href="#what-does-batch-contain" title="Link to this heading">¶</a></h3>
<p>The content of <code class="docutils literal notranslate"><span class="pre">Batch</span></code> objects can be defined by the following rules.</p>
<ol class="arabic simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object can be an empty <code class="docutils literal notranslate"><span class="pre">Batch()</span></code>, or have at least one key-value pairs. <code class="docutils literal notranslate"><span class="pre">Batch()</span></code> can be used to reserve keys, too. See <a class="reference internal" href="#key-reservations"><span class="std std-ref">Key Reservations</span></a> for this advanced usage.</p></li>
<li><p>The keys are always strings (they are names of corresponding values).</p></li>
<li><p>The values can be scalars, tensors, or Batch objects. The recursive definition makes it possible to form a hierarchy of batches.</p></li>
<li><p>Tensors are the most important values. In short, tensors are n-dimensional arrays of the same data type. We support two types of tensors: <a class="reference external" href="https://pytorch.org/">PyTorch</a> tensor type <code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code> and <a class="reference external" href="https://numpy.org/">NumPy</a> tensor type <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code>.</p></li>
<li><p>Scalars are also valid values. A scalar is a single boolean, number, or object. They can be python scalar (<code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2.3</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">'hello'</span></code>) or NumPy scalar (<code class="docutils literal notranslate"><span class="pre">np.bool_(True)</span></code>, <code class="docutils literal notranslate"><span class="pre">np.int32(1)</span></code>, <code class="docutils literal notranslate"><span class="pre">np.float64(2.3)</span></code>). They just shouldn’t be mixed up with Batch/dict/tensors.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">Batch</span></code> cannot store <code class="docutils literal notranslate"><span class="pre">dict</span></code> objects, because internally <code class="docutils literal notranslate"><span class="pre">Batch</span></code> uses <code class="docutils literal notranslate"><span class="pre">dict</span></code> to store data. During construction, <code class="docutils literal notranslate"><span class="pre">dict</span></code> objects will be automatically converted to <code class="docutils literal notranslate"><span class="pre">Batch</span></code> objects.</p>
<p>The data types of tensors are bool and numbers (any size of int and float as long as they are supported by NumPy or PyTorch). Besides, NumPy supports ndarray of objects and we take advantage of this feature to store non-number objects in <code class="docutils literal notranslate"><span class="pre">Batch</span></code>. If one wants to store data that are neither boolean nor numbers (such as strings and sets), they can store the data in <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> with the <code class="docutils literal notranslate"><span class="pre">np.object</span></code> data type. This way, <code class="docutils literal notranslate"><span class="pre">Batch</span></code> can store any type of python objects.</p>
</div>
</section>
<section id="construction-of-batch">
<h3>Construction of Batch<a class="headerlink" href="#construction-of-batch" title="Link to this heading">¶</a></h3>
<p>There are two ways to construct a <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object: from a <code class="docutils literal notranslate"><span class="pre">dict</span></code>, or using <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>. Below are some code snippets.</p>
<details>
<summary>Construct Batch from dict</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># directly passing a dict object (possibly nested) is ok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;2312312&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the list will automatically be converted to numpy array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">b</span>
<span class="go">array([5, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Batch(</span>
<span class="go">    a: 4,</span>
<span class="go">    b: array([3, 4, 5]),</span>
<span class="go">    c: &#39;2312312&#39;,</span>
<span class="go">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># a list of dict objects (possibly nested) will be automatically stacked</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">([{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s2">&quot;hello&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s2">&quot;world&quot;</span><span class="p">}])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Batch(</span>
<span class="go">    a: array([0., 1.]),</span>
<span class="go">    b: array([&#39;hello&#39;, &#39;world&#39;], dtype=object),</span>
<span class="go">)</span>
</pre></div>
</div>
</details><br><details>
<summary>Construct Batch from kwargs</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># construct a Batch with keyword arguments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Batch(</span>
<span class="go">    a: array([4, 4]),</span>
<span class="go">    b: array([5, 5]),</span>
<span class="go">    c: array([None, None], dtype=object),</span>
<span class="go">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># combining keyword arguments and batch_dict works fine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]},</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="c1"># the first argument is a dict, and &#39;c&#39; is a keyword argument</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Batch(</span>
<span class="go">    a: array([4, 4]),</span>
<span class="go">    b: array([5, 5]),</span>
<span class="go">    c: array([None, None], dtype=object),</span>
<span class="go">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># By default, Batch only keeps the reference to the data, but it also supports data copying</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">arr</span><span class="o">=</span><span class="n">arr</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># data.arr now is a copy of &#39;arr&#39;</span>
</pre></div>
</div>
</details><br></section>
<section id="data-manipulation-with-batch">
<h3>Data Manipulation With Batch<a class="headerlink" href="#data-manipulation-with-batch" title="Link to this heading">¶</a></h3>
<p>Users can access the internal data by <code class="docutils literal notranslate"><span class="pre">b.key</span></code> or <code class="docutils literal notranslate"><span class="pre">b[key]</span></code>, where <code class="docutils literal notranslate"><span class="pre">b.key</span></code> finds the sub-tree with <code class="docutils literal notranslate"><span class="pre">key</span></code> as the root node. If the result is a sub-tree with non-empty keys, the key-reference can be chained, i.e. <code class="docutils literal notranslate"><span class="pre">b.key.key1.key2.key3</span></code>. When it reaches a leaf node, users get the data (scalars/tensors) stored in that <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object.</p>
<details>
<summary>Access data stored in Batch</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
<span class="go">[5 5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># obj.key is equivalent to obj[&quot;key&quot;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">])</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iterating over data items like a dict is supported</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">a: 4</span>
<span class="go">b: [5, 5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># obj.keys() and obj.values() work just like dict.keys() and dict.values()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">a</span>
<span class="go">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># obj.update() behaves like dict.update()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># this is the same as data.c = 1; data.c = 2; data.e = 3;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Batch(</span>
<span class="go">    a: 4,</span>
<span class="go">    b: array([5, 5]),</span>
<span class="go">    c: 1,</span>
<span class="go">    d: 2,</span>
<span class="go">    e: 3,</span>
<span class="go">)</span>
</pre></div>
</div>
</details><br><div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">data</span></code> is a <code class="docutils literal notranslate"><span class="pre">dict</span></code> object, <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">data</span></code> iterates over keys in the dict. However, it has a different meaning for <code class="docutils literal notranslate"><span class="pre">Batch</span></code> objects: <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">data</span></code> iterates over <code class="docutils literal notranslate"><span class="pre">data[0],</span> <span class="pre">data[1],</span> <span class="pre">...,</span> <span class="pre">data[-1]</span></code>. An example is given below.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Batch</span></code> also partially reproduces the NumPy ndarray APIs. It supports advanced slicing, such as <code class="docutils literal notranslate"><span class="pre">batch[:,</span> <span class="pre">i]</span></code> so long as the slice is valid. Broadcast mechanism of NumPy works for <code class="docutils literal notranslate"><span class="pre">Batch</span></code>, too.</p>
<details>
<summary>Length, shape, indexing, and slicing of Batch</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># initialize Batch with tensors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]]),</span> <span class="n">b</span><span class="o">=</span><span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># if values have the same length/shape, that length/shape is used for this Batch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># else, check the advanced topic for details</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">[2, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># access the first item of all the stored tensors, while keeping the structure of Batch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">Batch(</span>
<span class="go">    a: array([0., 2.])</span>
<span class="go">    b: array([ 5, -5]),</span>
<span class="go">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iterates over ``data[0], data[1], ..., data[-1]``</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[0. 2.]</span>
<span class="go">[1. 3.]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Advanced slicing works just fine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Arithmetic operations are passed to each value in the Batch, with broadcast enabled</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Batch(</span>
<span class="go">    a: array([[0., 3.],</span>
<span class="go">              [1., 4.]]),</span>
<span class="go">    b: array([[ 5, -4]]),</span>
<span class="go">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># amazingly, you can directly apply np.mean to a Batch object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">Batch(</span>
<span class="go">    a: 1.5,</span>
<span class="go">    b: -0.25,</span>
<span class="go">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># directly converted to a list is also available</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">[Batch(</span>
<span class="go">     a: array([0., 3.]),</span>
<span class="go">     b: array([ 5, -4]),</span>
<span class="go"> ),</span>
<span class="go"> Batch(</span>
<span class="go">     a: array([1., 4.]),</span>
<span class="go">     b: array([ 1, -1]),</span>
<span class="go"> )]</span>
</pre></div>
</div>
</details><br><p>Stacking and concatenating multiple <code class="docutils literal notranslate"><span class="pre">Batch</span></code> instances, or split an instance into multiple batches, they are all easy and intuitive in Tianshou. For now, we stick to the aggregation (stack/concatenate) of homogeneous (same structure) batches. Stack/Concatenation of heterogeneous batches are discussed in <a class="reference internal" href="#aggregation"><span class="std std-ref">Aggregation of Heterogeneous Batches</span></a>.</p>
<details>
<summary>Stack / Concatenate / Split of Batches</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data_1</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]),</span> <span class="n">b</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_2</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]),</span> <span class="n">b</span><span class="o">=-</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Batch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Batch(</span>
<span class="go">    b: array([ 5, -5]),</span>
<span class="go">    a: array([[0., 2.],</span>
<span class="go">              [1., 3.]]),</span>
<span class="go">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># split supports random shuffling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_split</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>
<span class="go">[Batch(</span>
<span class="go">    b: array([5]),</span>
<span class="go">    a: array([[0., 2.]]),</span>
<span class="go">), Batch(</span>
<span class="go">    b: array([-5]),</span>
<span class="go">    a: array([[1., 3.]]),</span>
<span class="go">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_cat</span> <span class="o">=</span> <span class="n">Batch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">data_split</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data_cat</span><span class="p">)</span>
<span class="go">Batch(</span>
<span class="go">    b: array([ 5, -5]),</span>
<span class="go">    a: array([[0., 2.],</span>
<span class="go">              [1., 3.]]),</span>
<span class="go">)</span>
</pre></div>
</div>
</details><br></section>
</section>
<section id="advanced-topics">
<h2>Advanced Topics<a class="headerlink" href="#advanced-topics" title="Link to this heading">¶</a></h2>
<p>From here on, this tutorial focuses on advanced topics of <code class="docutils literal notranslate"><span class="pre">Batch</span></code>, including key reservation, length/shape, and aggregation of heterogeneous batches.</p>
<section id="key-reservations">
<span id="id1"></span><h3>Key Reservations<a class="headerlink" href="#key-reservations" title="Link to this heading">¶</a></h3>
<aside class="sidebar">
<p class="sidebar-title">The structure of a Batch with reserved keys</p>
<figure class="align-default">
<img alt="../_images/batch_reserve.png" src="../_images/batch_reserve.png" />
</figure>
</aside>
<p>In many cases, we know in the first place what keys we have, but we do not know the shape of values until we run the environment. To deal with this, Tianshou supports key reservations: <strong>reserve a key and use a placeholder value</strong>.</p>
<p>The usage is easy: just use <code class="docutils literal notranslate"><span class="pre">Batch()</span></code> to be the value of reserved keys.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">Batch</span><span class="p">())</span> <span class="c1"># &#39;b&#39; is a reserved key</span>
<span class="c1"># this is called hierarchical key reservation</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">Batch</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">Batch</span><span class="p">()),</span> <span class="n">d</span><span class="o">=</span><span class="n">Batch</span><span class="p">())</span> <span class="c1"># &#39;c&#39; and &#39;d&#39; are reserved key</span>
<span class="c1"># the structure of this last Batch is shown in the right figure</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">key1</span><span class="o">=</span><span class="n">tensor1</span><span class="p">,</span> <span class="n">key2</span><span class="o">=</span><span class="n">tensor2</span><span class="p">,</span> <span class="n">key3</span><span class="o">=</span><span class="n">Batch</span><span class="p">(</span><span class="n">key4</span><span class="o">=</span><span class="n">Batch</span><span class="p">(),</span> <span class="n">key5</span><span class="o">=</span><span class="n">Batch</span><span class="p">()))</span>
</pre></div>
</div>
<p>Still, we can use a tree (in the right) to show the structure of <code class="docutils literal notranslate"><span class="pre">Batch</span></code> objects with reserved keys, where reserved keys are special internal nodes that do not have attached leaf nodes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Reserved keys mean that in the future there will eventually be values attached to them. The values can be scalars, tensors, or even <strong>Batch</strong> objects. Understanding this is critical to understand the behavior of <code class="docutils literal notranslate"><span class="pre">Batch</span></code> when dealing with heterogeneous Batches.</p>
</div>
<p>The introduction of reserved keys gives rise to the need to check if a key is reserved. Tianshou provides <code class="docutils literal notranslate"><span class="pre">Batch.is_empty</span></code> to achieve this.</p>
<details>
<summary>Examples of Batch.is_empty</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Batch</span><span class="p">()</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">Batch</span><span class="p">(),</span> <span class="n">b</span><span class="o">=</span><span class="n">Batch</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">Batch</span><span class="p">()))</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">Batch</span><span class="p">(),</span> <span class="n">b</span><span class="o">=</span><span class="n">Batch</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">Batch</span><span class="p">()))</span><span class="o">.</span><span class="n">is_empty</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Batch</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</details><br><p>The <code class="docutils literal notranslate"><span class="pre">Batch.is_empty</span></code> function has an option to decide whether to identify direct emptiness (just a <code class="docutils literal notranslate"><span class="pre">Batch()</span></code>) or to identify recursive emptiness (a <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object without any scalar/tensor leaf nodes).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Do not get confused with <code class="docutils literal notranslate"><span class="pre">Batch.is_empty</span></code> and <code class="docutils literal notranslate"><span class="pre">Batch.empty</span></code>. <code class="docutils literal notranslate"><span class="pre">Batch.empty</span></code> and its in-place variant <code class="docutils literal notranslate"><span class="pre">Batch.empty_</span></code> are used to set some values to zeros or None. Check the API documentation for further details.</p>
</div>
</section>
<section id="length-and-shape">
<h3>Length and Shape<a class="headerlink" href="#length-and-shape" title="Link to this heading">¶</a></h3>
<p>The most common usage of <code class="docutils literal notranslate"><span class="pre">Batch</span></code> is to store a Batch of data. The term “Batch” comes from the deep learning community to denote a mini-batch of sampled data from the whole dataset. In this regard, “Batch” typically means a collection of tensors whose first dimensions are the same. Then the length of a <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object is simply the batch-size.</p>
<p>If all the leaf nodes in a <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object are tensors, but they have different lengths, they can be readily stored in <code class="docutils literal notranslate"><span class="pre">Batch</span></code>. However, for <code class="docutils literal notranslate"><span class="pre">Batch</span></code> of this kind, the <code class="docutils literal notranslate"><span class="pre">len(obj)</span></code> seems a bit ambiguous. Currently, Tianshou returns the length of the shortest tensor, but we strongly recommend that users do not use the <code class="docutils literal notranslate"><span class="pre">len(obj)</span></code> operator on <code class="docutils literal notranslate"><span class="pre">Batch</span></code> objects with tensors of different lengths.</p>
<details>
<summary>Examples of len and obj.shape for Batch objects</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">[2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">TypeError: Object of type &#39;Batch&#39; has no len()</span>
</pre></div>
</div>
</details><br><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Following the convention of scientific computation, scalars have no length. If there is any scalar leaf node in a <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object, an exception will occur when users call <code class="docutils literal notranslate"><span class="pre">len(obj)</span></code>.</p>
<p>Besides, values of reserved keys are undetermined, so they have no length, neither. Or, to be specific, values of reserved keys have lengths of <strong>any</strong>. When there is a mix of tensors and reserved keys, the latter will be ignored in <code class="docutils literal notranslate"><span class="pre">len(obj)</span></code> and the minimum length of tensors is returned. When there is not any tensor in the <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object, Tianshou raises an exception, too.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">obj.shape</span></code> attribute of <code class="docutils literal notranslate"><span class="pre">Batch</span></code> behaves somewhat similar to <code class="docutils literal notranslate"><span class="pre">len(obj)</span></code>:</p>
<ol class="arabic simple">
<li><p>If all the leaf nodes in a <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object are tensors with the same shape, that shape is returned.</p></li>
<li><p>If all the leaf nodes in a <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object are tensors but they have different shapes, the minimum length of each dimension is returned.</p></li>
<li><p>If there is any scalar value in a <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object, <code class="docutils literal notranslate"><span class="pre">obj.shape</span></code> returns <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p></li>
<li><p>The shape of reserved keys is undetermined, too. We treat their shape as <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p></li>
</ol>
</section>
<section id="aggregation-of-heterogeneous-batches">
<span id="aggregation"></span><h3>Aggregation of Heterogeneous Batches<a class="headerlink" href="#aggregation-of-heterogeneous-batches" title="Link to this heading">¶</a></h3>
<p>In this section, we talk about aggregation operators (stack/concatenate) on heterogeneous <code class="docutils literal notranslate"><span class="pre">Batch</span></code> objects.
The following picture will give you an intuitive understanding of this behavior. It shows two examples of aggregation operators with heterogeneous <code class="docutils literal notranslate"><span class="pre">Batch</span></code>. The shapes of tensors are annotated in the leaf nodes.</p>
<img alt="../_images/aggregation.png" src="../_images/aggregation.png" />
<p>We only consider the heterogeneity in the structure of <code class="docutils literal notranslate"><span class="pre">Batch</span></code> objects. The aggregation operators are eventually done by NumPy/PyTorch operators (<code class="docutils literal notranslate"><span class="pre">np.stack</span></code>, <code class="docutils literal notranslate"><span class="pre">np.concatenate</span></code>, <code class="docutils literal notranslate"><span class="pre">torch.stack</span></code>, <code class="docutils literal notranslate"><span class="pre">torch.cat</span></code>). Heterogeneity in values can fail these operators (such as stacking <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> with <code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code>, or stacking tensors with different shapes) and an exception will be raised.</p>
<p>The behavior is natural: for keys that are not shared across all batches, batches that do not have these keys will be padded by zeros (or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the data type is <code class="docutils literal notranslate"><span class="pre">np.object</span></code>). It can be written in the following scripts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># examples of stack: a is missing key `b`, and b is missing key `a`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="n">common</span><span class="o">=</span><span class="n">Batch</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]),</span> <span class="n">common</span><span class="o">=</span><span class="n">Batch</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Batch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 4, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 4, 6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">common</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># None or 0 is padded with appropriate shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_1</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_2</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]),</span> <span class="n">b</span><span class="o">=</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Batch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Batch(</span>
<span class="go">    a: array([[0., 2.],</span>
<span class="go">              [1., 3.]]),</span>
<span class="go">    b: array([None, &#39;done&#39;], dtype=object),</span>
<span class="go">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># examples of cat: a is missing key `b`, and b is missing key `a`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="n">common</span><span class="o">=</span><span class="n">Batch</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">common</span><span class="o">=</span><span class="n">Batch</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Batch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(7, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(7, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">common</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(7, 5)</span>
</pre></div>
</div>
<p>However, there are some cases when batches are too heterogeneous that they cannot be aggregated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">Batch</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">Batch</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># this will raise an exception</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Batch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
</pre></div>
</div>
<p>Then how to determine if batches can be aggregated? Let’s rethink the purpose of reserved keys. What is the advantage of <code class="docutils literal notranslate"><span class="pre">a1=Batch(b=Batch())</span></code> over <code class="docutils literal notranslate"><span class="pre">a2=Batch()</span></code>? The only difference is that <code class="docutils literal notranslate"><span class="pre">a1.b</span></code> returns <code class="docutils literal notranslate"><span class="pre">Batch()</span></code> but <code class="docutils literal notranslate"><span class="pre">a2.b</span></code> raises an exception. That’s to say, <strong>we reserve keys for attribute reference</strong>.</p>
<p>We say a key chain <code class="docutils literal notranslate"><span class="pre">k=[key1,</span> <span class="pre">key2,</span> <span class="pre">...,</span> <span class="pre">keyn]</span></code> applies to <code class="docutils literal notranslate"><span class="pre">b</span></code> if the expression <code class="docutils literal notranslate"><span class="pre">b.key1.key2.{...}.keyn</span></code> is valid, and the result is <code class="docutils literal notranslate"><span class="pre">b[k]</span></code>.</p>
<p>For a set of <code class="docutils literal notranslate"><span class="pre">Batch</span></code> objects denoted as <span class="math notranslate nohighlight">\(S\)</span>, they can be aggregated if there exists a <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object <code class="docutils literal notranslate"><span class="pre">b</span></code> satisfying the following rules:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Key chain applicability: For any object <code class="docutils literal notranslate"><span class="pre">bi</span></code> in <span class="math notranslate nohighlight">\(S\)</span>, and any key chain <code class="docutils literal notranslate"><span class="pre">k</span></code>, if <code class="docutils literal notranslate"><span class="pre">bi[k]</span></code> is valid, then <code class="docutils literal notranslate"><span class="pre">b[k]</span></code> is valid.</p></li>
<li><p>Type consistency: If <code class="docutils literal notranslate"><span class="pre">bi[k]</span></code> is not <code class="docutils literal notranslate"><span class="pre">Batch()</span></code> (the last key in the key chain is not a reserved key), then the type of <code class="docutils literal notranslate"><span class="pre">b[k]</span></code> should be the same as <code class="docutils literal notranslate"><span class="pre">bi[k]</span></code> (both should be scalar/tensor/non-empty Batch values).</p></li>
</ol>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">Batch</span></code> object <code class="docutils literal notranslate"><span class="pre">b</span></code> satisfying these rules with the minimum number of keys determines the structure of aggregating <span class="math notranslate nohighlight">\(S\)</span>. The values are relatively easy to define: for any key chain <code class="docutils literal notranslate"><span class="pre">k</span></code> that applies to <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">b[k]</span></code> is the stack/concatenation of <code class="docutils literal notranslate"><span class="pre">[bi[k]</span> <span class="pre">for</span> <span class="pre">bi</span> <span class="pre">in</span> <span class="pre">S]</span></code> (if <code class="docutils literal notranslate"><span class="pre">k</span></code> does not apply to <code class="docutils literal notranslate"><span class="pre">bi</span></code>, the appropriate size of zeros or <code class="docutils literal notranslate"><span class="pre">None</span></code> are filled automatically). If <code class="docutils literal notranslate"><span class="pre">bi[k]</span></code> are all <code class="docutils literal notranslate"><span class="pre">Batch()</span></code>, then the aggregation result is also an empty <code class="docutils literal notranslate"><span class="pre">Batch()</span></code>.</p>
</section>
<section id="miscellaneous-notes">
<h3>Miscellaneous Notes<a class="headerlink" href="#miscellaneous-notes" title="Link to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Batch</span></code> is serializable and therefore Pickle compatible. <code class="docutils literal notranslate"><span class="pre">Batch</span></code> objects can be saved to disk and later restored by the python <code class="docutils literal notranslate"><span class="pre">pickle</span></code> module. This pickle compatibility is especially important for distributed sampling from environments.</p></li>
</ol>
<details>
<summary>Batch.to_torch and Batch.to_numpy</summary><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">to_torch</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">tensor([[0., 0., 0., 0.],</span>
<span class="go">        [0., 0., 0., 0.],</span>
<span class="go">        [0., 0., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># data.to_numpy is also available</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
</pre></div>
</div>
</details><br><ol class="arabic simple" start="2">
<li><p>It is often the case that the observations returned from the environment are all NumPy ndarray but the policy requires <code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code> for prediction and learning. In this regard, Tianshou provides helper functions to convert the stored data in-place into Numpy arrays or Torch tensors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">obj.stack_([a,</span> <span class="pre">b])</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">Batch.stack([obj,</span> <span class="pre">a,</span> <span class="pre">b])</span></code>, and <code class="docutils literal notranslate"><span class="pre">obj.cat_([a,</span> <span class="pre">b])</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">Batch.cat([obj,</span> <span class="pre">a,</span> <span class="pre">b])</span></code>. Considering the frequent requirement of concatenating two <code class="docutils literal notranslate"><span class="pre">Batch</span></code> objects, Tianshou also supports <code class="docutils literal notranslate"><span class="pre">obj.cat_(a)</span></code> to be an alias of <code class="docutils literal notranslate"><span class="pre">obj.cat_([a])</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Batch.cat</span></code> and <code class="docutils literal notranslate"><span class="pre">Batch.cat_</span></code> does not support <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument as <code class="docutils literal notranslate"><span class="pre">np.concatenate</span></code> and <code class="docutils literal notranslate"><span class="pre">torch.cat</span></code> currently.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Batch.stack</span></code> and <code class="docutils literal notranslate"><span class="pre">Batch.stack_</span></code> support the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument so that one can stack batches besides the first dimension. But be cautious, if there are keys that are not shared across all batches, <code class="docutils literal notranslate"><span class="pre">stack</span></code> with <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">!=</span> <span class="pre">0</span></code> is undefined, and will cause an exception currently.</p></li>
</ol>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="concepts.html" class="btn btn-neutral float-left" title="Basic concepts in Tianshou" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tictactoe.html" class="btn btn-neutral float-right" title="Multi-Agent RL" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Tianshou contributors..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>